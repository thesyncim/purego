//go:build ignore

// This program generates func_typed_generated.go
// Run with: go generate ./...

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
)

// Type represents a Go/C type for code generation
type Type struct {
	Go       string // Go type name
	ToUint   string // conversion to uintptr (for args)
	FromUint string // conversion from uintptr (for returns)
	IsFloat  bool   // needs float register
	IsPtr    bool   // is pointer type (needs unsafe import)
}

var types = []Type{
	{Go: "int", ToUint: "uintptr(%s)", FromUint: "int(%s)"},
	{Go: "int32", ToUint: "uintptr(%s)", FromUint: "int32(%s)"},
	{Go: "int64", ToUint: "uintptr(%s)", FromUint: "int64(%s)"},
	{Go: "uint", ToUint: "uintptr(%s)", FromUint: "uint(%s)"},
	{Go: "uint32", ToUint: "uintptr(%s)", FromUint: "uint32(%s)"},
	{Go: "uint64", ToUint: "uintptr(%s)", FromUint: "uint64(%s)"},
	{Go: "uintptr", ToUint: "%s", FromUint: "%s"},
	{Go: "unsafe.Pointer", ToUint: "uintptr(%s)", FromUint: "unsafe.Pointer(%s)", IsPtr: true},
	{Go: "bool", ToUint: "boolToUintptr(%s)", FromUint: "uintptrToBool(%s)"},
}

var argNames = []string{"a", "b", "c", "d", "e", "f", "g", "h"}

func main() {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by gen_typed.go; DO NOT EDIT.

//go:build (darwin || freebsd || linux || netbsd) && (amd64 || arm64)

package purego

import "unsafe"

// Bool conversion helpers
func boolToUintptr(b bool) uintptr {
	if b {
		return 1
	}
	return 0
}

func uintptrToBool(u uintptr) bool {
	return byte(u) != 0
}

func tryRegisterTypedGenerated(fptr any, cfn uintptr) bool {
	switch fn := fptr.(type) {
`)

	// Generate 0-arg functions with different return types
	for _, ret := range types {
		genZeroArg(&buf, ret)
	}
	// void return
	buf.WriteString(`	case *func():
		*fn = func() { Syscall0(cfn) }
		return true
`)

	// Generate 1-arg functions
	for _, arg := range types {
		for _, ret := range types {
			genOneArg(&buf, arg, ret)
		}
		// void return
		genOneArgVoid(&buf, arg)
	}

	// Generate 2-arg functions (same type for simplicity, plus common mixed)
	for _, t := range types {
		genTwoArgSame(&buf, t)
	}
	// Common mixed: (ptr, int) -> int
	genTwoArgMixed(&buf, types[7], types[0], types[0]) // unsafe.Pointer, int -> int
	genTwoArgMixed(&buf, types[7], types[6], types[6]) // unsafe.Pointer, uintptr -> uintptr

	// Generate 3-arg functions (same type)
	for _, t := range types {
		if !t.IsFloat { // skip floats for 3+ args to keep size reasonable
			genThreeArgSame(&buf, t)
		}
	}

	// Generate 4-arg functions (same type, integers only)
	for _, t := range types[:7] { // int types + uintptr only
		genFourArgSame(&buf, t)
	}

	// Generate 6-arg functions (int64, uintptr only)
	genSixArgSame(&buf, types[2]) // int64
	genSixArgSame(&buf, types[6]) // uintptr

	// Generate 8-arg functions (int64, uintptr only)
	genEightArgSame(&buf, types[2]) // int64
	genEightArgSame(&buf, types[6]) // uintptr

	buf.WriteString(`	}
	return false
}
`)

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "format error: %v\n", err)
		fmt.Fprintln(os.Stderr, buf.String())
		os.Exit(1)
	}

	if err := os.WriteFile("func_typed_generated.go", formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Generated func_typed_generated.go")
}

func genZeroArg(buf *bytes.Buffer, ret Type) {
	fmt.Fprintf(buf, `	case *func() %s:
		*fn = func() %s { return %s }
		return true
`, ret.Go, ret.Go, fmt.Sprintf(ret.FromUint, "Syscall0(cfn)"))
}

func genOneArg(buf *bytes.Buffer, arg, ret Type) {
	argConv := fmt.Sprintf(arg.ToUint, "a")
	retConv := fmt.Sprintf(ret.FromUint, "Syscall1(cfn, "+argConv+")")
	fmt.Fprintf(buf, `	case *func(%s) %s:
		*fn = func(a %s) %s { return %s }
		return true
`, arg.Go, ret.Go, arg.Go, ret.Go, retConv)
}

func genOneArgVoid(buf *bytes.Buffer, arg Type) {
	argConv := fmt.Sprintf(arg.ToUint, "a")
	fmt.Fprintf(buf, `	case *func(%s):
		*fn = func(a %s) { Syscall1(cfn, %s) }
		return true
`, arg.Go, arg.Go, argConv)
}

func genTwoArgSame(buf *bytes.Buffer, t Type) {
	a := fmt.Sprintf(t.ToUint, "a")
	b := fmt.Sprintf(t.ToUint, "b")
	ret := fmt.Sprintf(t.FromUint, fmt.Sprintf("Syscall2(cfn, %s, %s)", a, b))
	fmt.Fprintf(buf, `	case *func(%s, %s) %s:
		*fn = func(a, b %s) %s { return %s }
		return true
`, t.Go, t.Go, t.Go, t.Go, t.Go, ret)
}

func genTwoArgMixed(buf *bytes.Buffer, arg1, arg2, ret Type) {
	a := fmt.Sprintf(arg1.ToUint, "a")
	b := fmt.Sprintf(arg2.ToUint, "b")
	r := fmt.Sprintf(ret.FromUint, fmt.Sprintf("Syscall2(cfn, %s, %s)", a, b))
	fmt.Fprintf(buf, `	case *func(%s, %s) %s:
		*fn = func(a %s, b %s) %s { return %s }
		return true
`, arg1.Go, arg2.Go, ret.Go, arg1.Go, arg2.Go, ret.Go, r)
}

func genThreeArgSame(buf *bytes.Buffer, t Type) {
	args := make([]string, 3)
	for i := 0; i < 3; i++ {
		args[i] = fmt.Sprintf(t.ToUint, argNames[i])
	}
	ret := fmt.Sprintf(t.FromUint, fmt.Sprintf("Syscall3(cfn, %s)", strings.Join(args, ", ")))
	fmt.Fprintf(buf, `	case *func(%s, %s, %s) %s:
		*fn = func(a, b, c %s) %s { return %s }
		return true
`, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, ret)
}

func genFourArgSame(buf *bytes.Buffer, t Type) {
	args := make([]string, 4)
	for i := 0; i < 4; i++ {
		args[i] = fmt.Sprintf(t.ToUint, argNames[i])
	}
	ret := fmt.Sprintf(t.FromUint, fmt.Sprintf("Syscall4(cfn, %s)", strings.Join(args, ", ")))
	fmt.Fprintf(buf, `	case *func(%s, %s, %s, %s) %s:
		*fn = func(a, b, c, d %s) %s { return %s }
		return true
`, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, ret)
}

func genSixArgSame(buf *bytes.Buffer, t Type) {
	args := make([]string, 6)
	for i := 0; i < 6; i++ {
		args[i] = fmt.Sprintf(t.ToUint, argNames[i])
	}
	ret := fmt.Sprintf(t.FromUint, fmt.Sprintf("Syscall6(cfn, %s)", strings.Join(args, ", ")))
	fmt.Fprintf(buf, `	case *func(%s, %s, %s, %s, %s, %s) %s:
		*fn = func(a, b, c, d, e, f %s) %s { return %s }
		return true
`, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, ret)
}

func genEightArgSame(buf *bytes.Buffer, t Type) {
	args := make([]string, 8)
	for i := 0; i < 8; i++ {
		args[i] = fmt.Sprintf(t.ToUint, argNames[i])
	}
	ret := fmt.Sprintf(t.FromUint, fmt.Sprintf("Syscall8(cfn, %s)", strings.Join(args, ", ")))
	fmt.Fprintf(buf, `	case *func(%s, %s, %s, %s, %s, %s, %s, %s) %s:
		*fn = func(a, b, c, d, e, f, g, h %s) %s { return %s }
		return true
`, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, t.Go, ret)
}
