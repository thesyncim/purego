// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 The Ebitengine Authors

// purego-gen generates zero-allocation C function wrappers.
//
// Usage in your package:
//
//	//go:generate go run github.com/ebitengine/purego/cmd/purego-gen
//
//	var lib uintptr  // your loaded library
//
//	//purego:sym lib my_c_function
//	var myFunc func(int32, unsafe.Pointer, int32) int32
//
//	//purego:sym lib another_function
//	var anotherFunc func(uint64) uint64
//
// Then call the generated RegisterPuregoFuncs() after loading your library.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

var output = flag.String("o", "purego_gen.go", "output file")

type funcInfo struct {
	VarName string
	LibVar  string
	SymName string
	Args    []argInfo
	RetType string
	HasRet  bool
}

type argInfo struct {
	Name string
	Type string
}

func main() {
	flag.Parse()

	files, err := filepath.Glob("*.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
	var funcs []funcInfo
	var pkg string

	fset := token.NewFileSet()
	for _, file := range files {
		if file == *output {
			continue
		}

		f, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
		if err != nil {
			fmt.Fprintf(os.Stderr, "warning: skipping %s: %v\n", file, err)
			continue
		}

		if pkg == "" {
			pkg = f.Name.Name
		}

		ast.Inspect(f, func(n ast.Node) bool {
			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.VAR || genDecl.Doc == nil {
				return true
			}

			for _, spec := range genDecl.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok || len(vs.Names) == 0 {
					continue
				}

				// Look for //purego:sym libVar "symbol"
				for _, comment := range genDecl.Doc.List {
					if !strings.HasPrefix(comment.Text, "//purego:sym ") {
						continue
					}

					parts := strings.Fields(strings.TrimPrefix(comment.Text, "//purego:sym "))
					if len(parts) < 2 {
						fmt.Fprintf(os.Stderr, "invalid: %s (need: //purego:sym libVar symbol_name)\n", comment.Text)
						continue
					}
					if len(parts) > 2 {
						fmt.Fprintf(os.Stderr, "warning: ignoring extra parts in %s\n", comment.Text)
					}

					ft, ok := vs.Type.(*ast.FuncType)
					if !ok {
						continue
					}

					fi := funcInfo{
						VarName: vs.Names[0].Name,
						LibVar:  parts[0],
						SymName: strings.Trim(parts[1], `"`),
					}

					// Parse args
					idx := 0
					if ft.Params != nil {
						for _, field := range ft.Params.List {
							typ := exprToString(field.Type)
							if len(field.Names) == 0 {
								fi.Args = append(fi.Args, argInfo{fmt.Sprintf("a%d", idx), typ})
								idx++
							} else {
								for range field.Names {
									fi.Args = append(fi.Args, argInfo{fmt.Sprintf("a%d", idx), typ})
									idx++
								}
							}
						}
					}

					// Parse return
					if ft.Results != nil && len(ft.Results.List) > 0 {
						fi.RetType = exprToString(ft.Results.List[0].Type)
						fi.HasRet = true
					}

					// Validate types
					hasError := false
					for _, arg := range fi.Args {
						if err := validateType(arg.Type); err != nil {
							fmt.Fprintf(os.Stderr, "warning: %s.%s arg %s: %v\n", fi.VarName, fi.SymName, arg.Name, err)
							hasError = true
						}
					}
					if fi.HasRet {
						if err := validateType(fi.RetType); err != nil {
							fmt.Fprintf(os.Stderr, "warning: %s.%s return: %v\n", fi.VarName, fi.SymName, err)
							hasError = true
						}
					}
					if hasError {
						fmt.Fprintf(os.Stderr, "  skipping %s (use RegisterFunc for complex types)\n", fi.VarName)
						continue
					}

					funcs = append(funcs, fi)
				}
			}
			return true
		})
	}

	if len(funcs) == 0 {
		fmt.Println("No //purego:sym annotations found. Usage:")
		fmt.Println("")
		fmt.Println("  //purego:sym lib symbol_name")
		fmt.Println("  var myFunc func(int32, unsafe.Pointer) int32")
		return
	}

	generate(pkg, funcs)
}

func generate(pkg string, funcs []funcInfo) {
	var buf bytes.Buffer

	// Check if any function has pointer args (needs runtime import)
	needsRuntime := false
	needsBoolHelpers := false
	for _, f := range funcs {
		for _, arg := range f.Args {
			if needsKeepAlive(arg.Type) {
				needsRuntime = true
			}
			if arg.Type == "bool" {
				needsBoolHelpers = true
			}
		}
		if f.HasRet && f.RetType == "bool" {
			needsBoolHelpers = true
		}
	}

	fmt.Fprintf(&buf, `// Code generated by purego-gen. DO NOT EDIT.

//go:build (darwin || freebsd || linux || netbsd) && (amd64 || arm64)

package %s

import (
	"unsafe"
	"github.com/ebitengine/purego"`, pkg)
	if needsRuntime {
		buf.WriteString("\n\t\"runtime\"")
	}
	buf.WriteString("\n)\n\nvar _ unsafe.Pointer\n")

	// Add bool helper functions if needed
	if needsBoolHelpers {
		buf.WriteString(`
func boolToUintptr(b bool) uintptr {
	if b {
		return 1
	}
	return 0
}

func uintptrToBool(u uintptr) bool {
	return u != 0
}
`)
	}

	buf.WriteString("\nfunc RegisterPuregoFuncs() error {\n")

	for _, f := range funcs {
		fmt.Fprintf(&buf, "\t// %s -> %s\n", f.SymName, f.VarName)
		fmt.Fprintf(&buf, "\t{\n")
		fmt.Fprintf(&buf, "\t\tsym, err := purego.Dlsym(%s, %q)\n", f.LibVar, f.SymName)
		fmt.Fprintf(&buf, "\t\tif err != nil { return err }\n")
		fmt.Fprintf(&buf, "\t\t%s = %s\n", f.VarName, genClosure(f))
		fmt.Fprintf(&buf, "\t}\n")
	}

	fmt.Fprintf(&buf, "\treturn nil\n}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "format error: %v\n%s\n", err, buf.String())
		os.Exit(1)
	}

	if err := os.WriteFile(*output, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "error writing %s: %v\n", *output, err)
		os.Exit(1)
	}
	fmt.Printf("Generated %s (%d functions)\n", *output, len(funcs))
}

func genClosure(f funcInfo) string {
	var buf bytes.Buffer

	// Collect args that need KeepAlive
	var keepAliveArgs []string
	for _, arg := range f.Args {
		if needsKeepAlive(arg.Type) {
			keepAliveArgs = append(keepAliveArgs, arg.Name)
		}
	}

	// func(a0 type0, a1 type1) retType {
	buf.WriteString("func(")
	for i, arg := range f.Args {
		if i > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%s %s", arg.Name, arg.Type)
	}
	buf.WriteString(")")
	if f.HasRet {
		fmt.Fprintf(&buf, " %s", f.RetType)
	}
	buf.WriteString(" { ")

	n := len(f.Args)
	useSyscallN := n > 15 // Now we have Syscall0-15, only need SyscallN for >15 args

	// If we have KeepAlive args, we need multi-statement body
	if len(keepAliveArgs) > 0 {
		// r := retType(purego.SyscallN(...))
		if f.HasRet {
			buf.WriteString("_r := ")
			if f.RetType == "bool" {
				buf.WriteString("uintptrToBool(")
			} else {
				fmt.Fprintf(&buf, "%s(", f.RetType)
			}
		}
		if useSyscallN {
			buf.WriteString("func() uintptr { r1, _, _ := purego.SyscallN(sym")
		} else {
			fmt.Fprintf(&buf, "purego.Syscall%d(sym", n)
		}
		for _, arg := range f.Args {
			buf.WriteString(", ")
			buf.WriteString(conv(arg.Name, arg.Type))
		}
		buf.WriteString(")")
		if useSyscallN {
			buf.WriteString("; return r1 }()")
		}
		if f.HasRet {
			buf.WriteString(")")
		}
		buf.WriteString("; ")

		// runtime.KeepAlive for each pointer arg
		for _, name := range keepAliveArgs {
			fmt.Fprintf(&buf, "runtime.KeepAlive(%s); ", name)
		}

		// return r
		if f.HasRet {
			buf.WriteString("return _r")
		}
	} else {
		// No KeepAlive needed - simple one-liner
		if f.HasRet {
			buf.WriteString("return ")
			if f.RetType == "bool" {
				buf.WriteString("uintptrToBool(")
			} else {
				fmt.Fprintf(&buf, "%s(", f.RetType)
			}
		}
		if useSyscallN {
			buf.WriteString("func() uintptr { r1, _, _ := purego.SyscallN(sym")
		} else {
			fmt.Fprintf(&buf, "purego.Syscall%d(sym", n)
		}
		for _, arg := range f.Args {
			buf.WriteString(", ")
			buf.WriteString(conv(arg.Name, arg.Type))
		}
		buf.WriteString(")")
		if useSyscallN {
			buf.WriteString("; return r1 }()")
		}
		if f.HasRet {
			buf.WriteString(")")
		}
	}
	buf.WriteString(" }")

	return buf.String()
}

func conv(name, typ string) string {
	switch {
	case typ == "uintptr":
		return name
	case typ == "unsafe.Pointer":
		return "uintptr(" + name + ")"
	case strings.HasPrefix(typ, "*"):
		return "uintptr(unsafe.Pointer(" + name + "))"
	case typ == "bool":
		return "boolToUintptr(" + name + ")"
	default:
		return "uintptr(" + name + ")"
	}
}

func needsKeepAlive(typ string) bool {
	return typ == "unsafe.Pointer" || strings.HasPrefix(typ, "*")
}

// unsupportedTypes that cannot be passed via Syscall functions
var unsupportedTypes = map[string]string{
	"float32":    "floats use different CPU registers; use RegisterFunc or manual Syscall with math.Float32bits",
	"float64":    "floats use different CPU registers; use RegisterFunc or manual Syscall with math.Float64bits",
	"complex64":  "complex types not supported in C FFI",
	"complex128": "complex types not supported in C FFI",
	"string":     "strings must be converted to *byte or unsafe.Pointer",
}

func validateType(typ string) error {
	// Check for unsupported base types
	if reason, ok := unsupportedTypes[typ]; ok {
		return fmt.Errorf("type %s: %s", typ, reason)
	}

	// Check for slice types
	if strings.HasPrefix(typ, "[]") {
		return fmt.Errorf("type %s: slices must be converted to unsafe.Pointer(&slice[0])", typ)
	}

	// Check for map types
	if strings.HasPrefix(typ, "map[") {
		return fmt.Errorf("type %s: maps cannot be passed to C", typ)
	}

	// Check for chan types
	if strings.HasPrefix(typ, "chan ") || strings.HasPrefix(typ, "<-chan") {
		return fmt.Errorf("type %s: channels cannot be passed to C", typ)
	}

	// Check for func types
	if strings.HasPrefix(typ, "func(") {
		return fmt.Errorf("type %s: use purego.NewCallback for function pointers", typ)
	}

	// Check for interface types
	if typ == "any" || typ == "interface{}" || strings.HasPrefix(typ, "interface{") {
		return fmt.Errorf("type %s: interfaces cannot be passed to C", typ)
	}

	return nil
}

func exprToString(e ast.Expr) string {
	switch t := e.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return exprToString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + exprToString(t.Elt)
		}
		return "[...]" + exprToString(t.Elt)
	case nil:
		return "any"
	default:
		return fmt.Sprintf("<%T>", e)
	}
}
