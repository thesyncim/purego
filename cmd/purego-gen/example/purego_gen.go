// Code generated by purego-gen. DO NOT EDIT.

//go:build (darwin || freebsd || linux || netbsd) && (amd64 || arm64)

package example

import (
	"github.com/ebitengine/purego"
	"runtime"
	"unsafe"
)

var _ unsafe.Pointer

func boolToUintptr(b bool) uintptr {
	if b {
		return 1
	}
	return 0
}

func uintptrToBool(u uintptr) bool {
	return u != 0
}

func RegisterPuregoFuncs() error {
	// bench_add -> benchAdd
	{
		sym, err := purego.Dlsym(lib, "bench_add")
		if err != nil {
			return err
		}
		benchAdd = func(a0 int64, a1 int64) int64 { return int64(purego.Syscall2(sym, uintptr(a0), uintptr(a1))) }
	}
	// bench_ptr -> benchPtr
	{
		sym, err := purego.Dlsym(lib, "bench_ptr")
		if err != nil {
			return err
		}
		benchPtr = func(a0 unsafe.Pointer, a1 int64) int64 {
			_r := int64(purego.Syscall2(sym, uintptr(a0), uintptr(a1)))
			runtime.KeepAlive(a0)
			return _r
		}
	}
	// is_valid -> isValid
	{
		sym, err := purego.Dlsym(lib, "is_valid")
		if err != nil {
			return err
		}
		isValid = func(a0 int32) bool { return uintptrToBool(purego.Syscall1(sym, uintptr(a0))) }
	}
	// opus_encode -> opusEncode
	{
		sym, err := purego.Dlsym(lib, "opus_encode")
		if err != nil {
			return err
		}
		opusEncode = func(a0 uint64, a1 unsafe.Pointer, a2 int32, a3 unsafe.Pointer, a4 int32) int32 {
			_r := int32(purego.Syscall5(sym, uintptr(a0), uintptr(a1), uintptr(a2), uintptr(a3), uintptr(a4)))
			runtime.KeepAlive(a1)
			runtime.KeepAlive(a3)
			return _r
		}
	}
	// process_data -> processData
	{
		sym, err := purego.Dlsym(lib, "process_data")
		if err != nil {
			return err
		}
		processData = func(a0 *int32, a1 *byte, a2 int64) int32 {
			_r := int32(purego.Syscall3(sym, uintptr(unsafe.Pointer(a0)), uintptr(unsafe.Pointer(a1)), uintptr(a2)))
			runtime.KeepAlive(a0)
			runtime.KeepAlive(a1)
			return _r
		}
	}
	// no_return_fn -> noReturnFn
	{
		sym, err := purego.Dlsym(lib, "no_return_fn")
		if err != nil {
			return err
		}
		noReturnFn = func(a0 int64, a1 int64, a2 int64) { purego.Syscall3(sym, uintptr(a0), uintptr(a1), uintptr(a2)) }
	}
	// many_args -> manyArgs
	{
		sym, err := purego.Dlsym(lib, "many_args")
		if err != nil {
			return err
		}
		manyArgs = func(a0 int64, a1 int64, a2 int64, a3 int64, a4 int64, a5 int64, a6 int64, a7 int64, a8 int64) int64 {
			return int64(purego.Syscall9(sym, uintptr(a0), uintptr(a1), uintptr(a2), uintptr(a3), uintptr(a4), uintptr(a5), uintptr(a6), uintptr(a7), uintptr(a8)))
		}
	}
	// bool_and -> boolAnd
	{
		sym, err := purego.Dlsym(lib, "bool_and")
		if err != nil {
			return err
		}
		boolAnd = func(a0 bool, a1 bool) bool {
			return uintptrToBool(purego.Syscall2(sym, boolToUintptr(a0), boolToUintptr(a1)))
		}
	}
	return nil
}
